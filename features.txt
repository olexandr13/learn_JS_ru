// + приводит строку к числу
var a = "5";
+a - выведет 5
var age = +prompt("Сколько вам лет?", 20);


// !! преобразует значение к логическому типу
var a = "строка"
!!a - получим true


// преобразование типов
String(5)
Number("5")
Boolean(5)


// преобразование типов
"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
7 / 0 = Infinity
" -9\n" + 5 = " -9\n5"
" -9\n" - 5 = -14
5 && 2 = 2
2 && 5 = 5
5 || 0 = 5
0 || 5 = 5
null + 1 = 1 // (3)
undefined + 1 = NaN // (4)
null == "\n0\n" = false // (5)
+null == +"\n0\n" = true // (6)

(1) Оператор "+" в данном случае прибавляет 1 как строку, и затем 0.
(2) Оператор "-" работает только с числами, так что он сразу приводит "" к 0.
(3) null при численном преобразовании становится 0
(4) undefined при численном преобразовании становится NaN
(5) При сравнении == с null преобразования не происходит, есть жёсткое правило: null == undefined и только.
(6) И левая и правая часть == преобразуются к числу 0.

Метод num.toFixed(n)
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой,
при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода):
 var n = 12.345;
alert( n.toFixed(2) ); // "12.35"
alert( n.toFixed(0) ); // "12"
alert( n.toFixed(5) ); // "12.34500"

alert( 3e5 ); // 300000
alert( 3e-5 ); // 0.00003

Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true,
если получилось NaN, и false – для любого другого значения.
 var n = 0 / 0;
alert( isNaN(n) ); // true

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

isNaN(str)
преобразует строку в число аналогично +, а затем вернёт true, если это NaN, т.е. если преобразование не удалось

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число,
а parseFloat – дробное.
 alert( parseInt('12px') ) // 12, ошибка на символе 'p'

Если нужна действительно точная проверка на число, которая не считает числом строку из пробелов,
логические и специальные значения, а также отсекает Infinity – используйте следующую функцию:
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

Math.floor
Округляет вниз
Math.ceil
Округляет вверх
Math.round
Округляет до ближайшего целого

Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей.
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46


----- Строки -----
Чтобы получить символ, используйте вызов charAt(позиция).
var str = "jQuery";
alert( str.charAt(0) ); // "j"
Также для доступа к символу можно также использовать квадратные скобки:
var str = "Я - современный браузер!";
alert( str[0] ); // "Я
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку,
а скобки – undefined

Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).

Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
alert( ~2 ); // -(2+1) = -3
alert( ~1 ); // -(1+1) = -2
alert( ~0 ); // -(0+1) = -1
alert( ~-1 ); // -(-1+1) = 0
Как видно, ~n – ноль только в случае, когда n == -1.
То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
Вот так:
 var str = "Widget";
if (~str.indexOf("get")) {
  alert( 'совпадение есть!' );
}
Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf"
читается как "если найдено".

substring(start [, end])
Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
var str = "stringify";
alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
Если аргумент end отсутствует, то идет до конца строки
substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
var str = "stringify";
str = str.substr(2,4); // ring, со 2-й позиции 4 символа
Если второго аргумента нет – подразумевается «до конца строки».
slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.

Отрицательные аргументы
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
"testme".substring(-2); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
 alert( "testme".substring(4, -1) ); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
slice
Отрицательные значения отсчитываются от конца строки:
 alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
 alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
Это гораздо более удобно, чем странная логика substring.
Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice:
 он и отрицательные аргументы поддерживает и работает наиболее очевидно.

----- Объекты как ассоциативные массивы -----
Есть два средства для проверки наличия свойства в объекте: первое – оператор in,
второе – получить его и сравнить с undefined.
Они почти идентичны, но есть одна небольшая разница.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined:
var obj = {};
obj.test = undefined; // добавили свойство со значением undefined
// проверим наличие свойств test и заведомо отсутствующего blabla
alert( obj.test === undefined ); // true
alert( obj.blabla === undefined ); // true
…При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.
Но оператор in гарантирует правильный результат:
var obj = {};
obj.test = undefined;
alert( "test" in obj ); // true
alert( "blabla" in obj ); // false
Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки.
 А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.

----- Массивы с числовыми индексами -----
Операции с концом массива:
arr.push(элемент1, элемент2...) добавляет элементы в конец.
var elem = arr.pop() удаляет и возвращает последний элемент.
Операции с началом массива:
arr.unshift(элемент1, элемент2...) добавляет элементы в начало.
var elem = arr.shift() удаляет и возвращает первый элемент.

----- Массивы: методы -----
push/pop, shift/unshift, splice – для добавления и удаления элементов.
join/split – для преобразования строки в массив и обратно.
slice – копирует участок массива.
sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.
reverse – меняет порядок элементов на обратный.
concat – объединяет массивы.
indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).